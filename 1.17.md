## [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)
### æµ‹è¯•æ•°æ®
`[1,1,1,2,2,3]
2`
### è¾“å‡º
`1,2`
```c++
class myCompare{//ä»¿å‡½æ•°ä¸æ˜¯å‡½æ•°ï¼Œæ˜¯ä¸€ä¸ªç±»ï¼Œåªæ˜¯è¿™ä¸ªç±»ä¸­åªé‡è½½()æ“ä½œç¬¦
public:
    bool operator()(const pair<int, int> &l, const pair<int, int> &r) const {
        return l.second > r.second;
    }
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        for (int i : nums) {
            mp[i]++;//ä½¿ç”¨mpçš„keyè¡¨ç¤ºæŸä¸ªæ•°å­—ï¼Œmpçš„valueè¡¨ç¤ºå‡ºç°æ¬¡æ•°
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, myCompare> que;//å®šä¹‰å°æ ¹å †ï¼Œè‡ªå®šä¹‰ä»¿å‡½æ•°myCompare
        for (auto it = mp.begin(); it != mp.end(); it++){//unordered_map<int, int>::iterator it å¯ä»¥ä½¿ç”¨è¯­æ³•ğŸ¬æ¢ä¸º auto it.ä½†æ˜¯ä¸è¦å¿˜è®°åŸæ¥è¿­ä»£å™¨çš„å†™æ³•
            que.push(*it);
            if (que.size() > k) {
                que.pop();
            }
        }
        vector<int> res(k);//ç”¨kæŒ‡å®šreså¤§å°ï¼Œå¦åˆ™ä¸èƒ½ä½¿ç”¨res[i]è®¿é—®resçš„ç¬¬iä¸ªå…ƒç´ 
        for (int i = k - 1; i >= 0; i--) {
            res[i] = que.top().first;//ä¸èƒ½ç”¨res.push_back(que.top().first);
            //å¦åˆ™æ˜¯åœ¨res={0,0}åå…ˆæ’å…¥æœ€å°çš„ï¼Œæœ€åæ’å…¥æœ€å¤§çš„ã€‚è¾“å‡º{0,0,2,1}
            que.pop();
        }
        return res;
    }
};
```

## [144. Binary Tree Preorder Traversal](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
### é€’å½’æ³•ï¼š
```c++
class Solution {
public:
    void preorderFun(TreeNode* root, vector<int>& res) {
        if (root == nullptr) {
            return;
        }
        res.push_back(root->val);
        preorderFun(root->left, res);
        preorderFun(root->right, res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        preorderFun(root, res);
        return res;
        
    }
};
```
### è¿­ä»£æ³•ï¼šï¼ˆä½¿ç”¨stackï¼‰
```c++
class Solution {
public:
    
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;//æ³¨æ„stä¸­å­˜å‚¨çš„ç±»å‹æ˜¯TreeNode*ï¼Œä¸æ˜¯int
        if (root == nullptr) {
            return res;
        }
        st.push(root);
        while (!st.empty()) {
            TreeNode* cur = st.top();
            st.pop();
            res.push_back(cur->val);
            if (cur->right != nullptr) {
                st.push(cur->right);
            }
            if (cur->left != nullptr) {
                st.push(cur->left);
            }
        }
        return res;
    }
};
```

## [145. äºŒå‰æ ‘çš„ååºéå†](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
### é€’å½’æ³•ï¼š
```c++
class Solution {
public:
    void postorderFun(TreeNode* cur, vector<int>& res) {
        if (cur == nullptr) {
            return;
        }
        postorderFun(cur->left, res);
        postorderFun(cur->right, res);
        res.push_back(cur->val);
        return;
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        postorderFun(root, res);
        return res;
    }
};
```
### â€¼ï¸è¿­ä»£æ³•
`âŒç­”æ¡ˆ`
```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* last;
        if (root == nullptr) {
            return res;
        }
        st.push(root);
        while (!st.empty()) {
            TreeNode* cur = st.top();
            while (cur->left != nullptr && cur->left != last) {
                cur = cur->left;
                st.push(cur);
            }
            if (cur->right != nullptr && cur->right != last) {//cur->right != lastå¾ˆé‡è¦
                cur = cur->right;
                st.push(cur);
            }
            else {
                cur = st.top();
                last = cur;
                res.push_back(cur->val);
                st.pop();
            }
        }
        return res;
    }
};
```
`âœ…ç­”æ¡ˆ`
```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* last;
        if (root == nullptr) {
            return res;
        }
        st.push(root);
        TreeNode* cur = root;
        while (!st.empty()) {
            while (cur != nullptr && cur->left != nullptr) {
                cur = cur->left;
                st.push(cur);
            }
            cur = st.top();//cur=st.top()ä¸èƒ½åœ¨whileå¾ªç¯ä¹‹å‰ï¼Œå› ä¸ºè®¿é—®å®Œå½“å‰å…ƒç´ åå–æ ˆé¡¶æ—¶ï¼Œä¸èƒ½å†å»å·¦è¾¹è®©å·¦è¾¹è¿›æ ˆäº†
            if (cur->right != nullptr && cur->right != last) {//cur->right != lastå¾ˆé‡è¦
                cur = cur->right;
                st.push(cur);
            }
            else {
                cur = st.top();
                last = cur;
                res.push_back(cur->val);
                st.pop();//è®¿é—®å®Œå½“å‰å…ƒç´ äº†ï¼Œè¯´æ˜å½“å‰å…ƒç´ æ²¡æœ‰å·¦å³å„¿å­ï¼Œé‚£ä¹ˆå›å»åç¬¬ä¸€ä¸ªwhileä¸ä¼šæ‰§è¡Œã€‚
                cur = nullptr;//é˜²æ­¢å†å‘å·¦éå†
            }
        }
        return res;
    }
};
```
