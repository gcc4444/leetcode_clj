## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
### 测试数据
`[1,1,1,2,2,3]
2`
### 输出
`1,2`
```c++
class myCompare{//仿函数不是函数，是一个类，只是这个类中只重载()操作符
public:
    bool operator()(const pair<int, int> &l, const pair<int, int> &r) const {
        return l.second > r.second;
    }
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        for (int i : nums) {
            mp[i]++;//使用mp的key表示某个数字，mp的value表示出现次数
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, myCompare> que;//定义小根堆，自定义仿函数myCompare
        for (auto it = mp.begin(); it != mp.end(); it++){//unordered_map<int, int>::iterator it 可以使用语法🍬换为 auto it.但是不要忘记原来迭代器的写法
            que.push(*it);
            if (que.size() > k) {
                que.pop();
            }
        }
        vector<int> res(k);//用k指定res大小，否则不能使用res[i]访问res的第i个元素
        for (int i = k - 1; i >= 0; i--) {
            res[i] = que.top().first;//不能用res.push_back(que.top().first);
            //否则是在res={0,0}后先插入最小的，最后插入最大的。输出{0,0,2,1}
            que.pop();
        }
        return res;
    }
};
```
